name: 'Deploy Application'
description: 'Deploy status monitoring application stack'
inputs:
  environment:
    description: 'Deployment environment'
    required: true
  compose-file:
    description: 'Docker compose file'
    required: false
    default: 'docker-compose.yml'
  services:
    description: 'Specific services to deploy'
    required: false
    default: 'all'
  wait-for-healthy:
    description: 'Wait for services to be healthy'
    required: false
    default: 'true'
  domain-name:
    description: 'Domain name for deployment'
    required: true
  frontend-fqdn:
    description: 'Frontend FQDN for deployment'
    required: true
  api-fqdn:
    description: 'API FQDN for deployment'
    required: true
  server-user:
    description: 'Server user for deployment'
    required: true
  github-token:
    description: 'GitHub token for registry access'
    required: true
  image-tag:
    description: 'Docker image tag to deploy'
    required: false
    default: ${{ github.sha }}
  secrets-json:
    description: 'JSON string containing all application secrets'
    required: true
outputs:
  deployment-status:
    description: 'Deployment status'
    value: ${{ steps.deploy.outputs.status }}
  deployed-services:
    description: 'Successfully deployed services'
    value: ${{ steps.deploy.outputs.services }}
  deployment-url:
    description: 'Deployment URL'
    value: ${{ steps.deploy.outputs.url }}
runs:
  using: composite
  steps:
    - name: Validate deployment inputs
      shell: bash
      run: |
        echo "ðŸ” Validating deployment configuration..."
        echo "Environment: ${{ inputs.environment }}"
        echo "Domain: ${{ inputs.domain-name }}"
        echo "Image tag: ${{ inputs.image-tag }}"
        echo "Services: ${{ inputs.services }}"

    - name: Setup SSH connection
      shell: bash
      run: |
        echo "ðŸ” Setting up SSH connection..."
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        ssh-keyscan -H ${{ inputs.domain-name }} >> ~/.ssh/known_hosts

        if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ inputs.server-user }}@${{ inputs.domain-name }} "echo 'SSH connection test successful'"; then
          echo "âœ… SSH connection established"
        else
          echo "âŒ SSH connection failed"
          exit 1
        fi

    - name: Prepare deployment files and secrets
      shell: bash
      run: |
        echo "ðŸ“¦ Preparing deployment files..."
        mkdir -p deployment-temp

        # Copy docker-compose file
        if [ -f "${{ inputs.compose-file }}" ]; then
          cp "${{ inputs.compose-file }}" deployment-temp/
          echo "âœ… Copied compose file: ${{ inputs.compose-file }}"
        else
          echo "âŒ Compose file not found: ${{ inputs.compose-file }}"
          exit 1
        fi

        # Update image tags
        echo "ðŸ·ï¸ Updating image tags to :${{ inputs.image-tag }}"
        sed -i "s|ghcr.io/${{ github.repository }}/\([^:]*\):latest|ghcr.io/${{ github.repository }}/\1:${{ inputs.image-tag }}|g" deployment-temp/${{ inputs.compose-file }}
        sed -i "s|ghcr.io/${{ github.repository }}/\([^:]*\)$|ghcr.io/${{ github.repository }}/\1:${{ inputs.image-tag }}|g" deployment-temp/${{ inputs.compose-file }}

        # Replace FQDN variables in docker-compose file
        echo "ðŸŒ Replacing FQDN variables in compose file..."
        sed -i "s/\${FRONTEND_FQDN}/${{ inputs.frontend-fqdn }}/g" deployment-temp/${{ inputs.compose-file }}
        sed -i "s/\${API_FQDN}/${{ inputs.api-fqdn }}/g" deployment-temp/${{ inputs.compose-file }}
        echo "âœ… FQDN variables replaced successfully"

        # ðŸ”‘ JSON to .env conversion - This is the key part!
        echo "ðŸ”‘ Converting JSON secrets to .env file..."

        # Parse JSON and convert to .env format
        echo '${{ inputs.secrets-json }}' | jq -r '
          # Handle nested oauth structure
          if has("oauth") then
            (.oauth | to_entries[] | 
              (.key | ascii_upcase) + "_CLIENT_ID=" + .value.client_id,
              (.key | ascii_upcase) + "_CLIENT_SECRET=" + .value.client_secret
            ),
            # Handle direct properties
            (to_entries[] | select(.key != "oauth") | 
              (.key | ascii_upcase) + "=" + (.value | tostring)
            )
          else
            # Flat structure fallback
            to_entries[] | (.key | ascii_upcase) + "=" + (.value | tostring)
          end
        ' > deployment-temp/.env

        # Set secure permissions
        chmod 600 deployment-temp/.env

        # Add FQDN environment variables for service routing
        echo "ðŸŒ Adding FQDN environment variables..."
        cat >> deployment-temp/.env << EOF
        FRONTEND_FQDN=${{ inputs.frontend-fqdn }}
        API_FQDN=${{ inputs.api-fqdn }}
        EOF

        echo "âœ… .env file created with secrets and FQDN variables"
        echo "ðŸ“Š .env file contains $(wc -l < deployment-temp/.env) environment variables"

    - name: Deploy to remote server
      id: deploy
      shell: bash
      run: |
        echo "ðŸš€ Starting deployment to ${{ inputs.environment }}..."

        REMOTE_DIR="/opt/agentage/${{ inputs.environment }}"
        STACK_NAME="agentage-${{ inputs.environment }}"

        # Create remote directory
        ssh ${{ inputs.server-user }}@${{ inputs.domain-name }} "mkdir -p ${REMOTE_DIR}"

        # Copy files to server
        echo "ðŸ“¤ Copying deployment files..."
        scp deployment-temp/${{ inputs.compose-file }} ${{ inputs.server-user }}@${{ inputs.domain-name }}:${REMOTE_DIR}/
        scp deployment-temp/.env ${{ inputs.server-user }}@${{ inputs.domain-name }}:${REMOTE_DIR}/

        # Set secure permissions on remote .env file
        ssh ${{ inputs.server-user }}@${{ inputs.domain-name }} "chmod 600 ${REMOTE_DIR}/.env"

        # GitHub Container Registry login
        echo "ðŸ” Authenticating with GHCR..."
        ssh ${{ inputs.server-user }}@${{ inputs.domain-name }} "echo '${{ inputs.github-token }}' | docker login ghcr.io -u ${{ github.actor }} --password-stdin"

        # Deploy using docker stack (Swarm mode)
        echo "ðŸ”„ Deploying stack to Docker Swarm..."
        ssh ${{ inputs.server-user }}@${{ inputs.domain-name }} "cd ${REMOTE_DIR} && \
          docker stack deploy -c ${{ inputs.compose-file }} ${STACK_NAME} --with-registry-auth"

        # Force update services to pick up new environment variables
        echo "ðŸ”„ Updating services with environment variables..."
        ssh ${{ inputs.server-user }}@${{ inputs.domain-name }} "cd ${REMOTE_DIR} && \
          if docker service ls --format '{{.Name}}' | grep -q '^${STACK_NAME}_backend$'; then
            echo 'Updating backend service with .env variables...'
            env_args=\"\"
            while IFS='=' read -r key value; do
              if [[ -n \"\$key\" && ! \"\$key\" =~ ^# ]]; then
                env_args=\"\$env_args --env-add \$key=\$value\"
              fi
            done < .env
            docker service update \$env_args --force ${STACK_NAME}_backend >/dev/null 2>&1 || true
          fi
        "

        if [ $? -eq 0 ]; then
          echo "âœ… Stack deployed successfully"
          echo "status=success" >> $GITHUB_OUTPUT
          echo "services=backend,frontend" >> $GITHUB_OUTPUT
          echo "url=https://${{ inputs.domain-name }}" >> $GITHUB_OUTPUT
        else
          echo "âŒ Stack deployment failed"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Verify deployment
      shell: bash
      run: |
        echo "ðŸŽ‰ Deployment completed successfully!"
        echo "Environment: ${{ inputs.environment }}"
        echo "Status: âœ… Success"
        echo "URL: https://${{ inputs.domain-name }}"

    - name: Cleanup
      if: always()
      shell: bash
      run: |
        echo "ðŸ§¹ Cleaning up temporary files..."
        rm -rf deployment-temp
        echo "âœ… Cleanup completed"
